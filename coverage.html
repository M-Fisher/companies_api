
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>companies: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/M-Fisher/companies_api/app/api/endpoints/companies/companies.go (91.5%)</option>
				
				<option value="file1">github.com/M-Fisher/companies_api/app/internal/services/auth/actions.go (100.0%)</option>
				
				<option value="file2">github.com/M-Fisher/companies_api/app/internal/services/auth/auth.go (0.0%)</option>
				
				<option value="file3">github.com/M-Fisher/companies_api/app/internal/services/auth/jwt.go (86.7%)</option>
				
				<option value="file4">github.com/M-Fisher/companies_api/app/internal/services/auth/mock_AuthService.go (0.0%)</option>
				
				<option value="file5">github.com/M-Fisher/companies_api/app/internal/services/auth/mock_IPDataProvider.go (80.0%)</option>
				
				<option value="file6">github.com/M-Fisher/companies_api/app/internal/services/companies/companies.go (0.0%)</option>
				
				<option value="file7">github.com/M-Fisher/companies_api/app/internal/services/companies/create_company.go (0.0%)</option>
				
				<option value="file8">github.com/M-Fisher/companies_api/app/internal/services/companies/delete_company.go (100.0%)</option>
				
				<option value="file9">github.com/M-Fisher/companies_api/app/internal/services/companies/get_companies.go (100.0%)</option>
				
				<option value="file10">github.com/M-Fisher/companies_api/app/internal/services/companies/helpers.go (100.0%)</option>
				
				<option value="file11">github.com/M-Fisher/companies_api/app/internal/services/companies/mock_CompaniesService.go (0.0%)</option>
				
				<option value="file12">github.com/M-Fisher/companies_api/app/internal/services/companies/update_company.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package companies

import (
        "context"
        "errors"
        "net/http"

        "go.uber.org/zap"

        "github.com/M-Fisher/companies_api/app/api/base"
        "github.com/M-Fisher/companies_api/app/internal/logger"
        "github.com/M-Fisher/companies_api/app/internal/models"
        "github.com/M-Fisher/companies_api/app/internal/services/auth"
)

// CompaniesAPI - common API struct for companies
type CompaniesAPI struct {
        base.API
}

// SetRoutes initial routing
func (a *CompaniesAPI) SetRoutes() <span class="cov0" title="0">{
        a.API.SetJSONHandler("", a.GetCompanies).Methods("GET")
        a.API.SetJSONHandler("/{id}", a.UpdateCompany).Methods("PUT")
        a.API.SetJSONHandler("/{id}", a.DeleteCompany).Methods("DELETE")
        a.API.SetJSONHandler("", a.CreateCompany).Methods("POST")
}</span>

func (a *CompaniesAPI) GetCompanies(ctx context.Context, rw http.ResponseWriter, r *http.Request) (any, error) <span class="cov6" title="3">{
        log := logger.FromContext(ctx).With(zap.String("method", "GetCompanies"))
        var data models.GetCompanyRequest
        err := base.DecodeQuery(&amp;data, r)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to decode query params", zap.Error(err))
                return base.Response{}, errors.New(`incorrect params`)
        }</span>

        <span class="cov6" title="3">cmp, err := a.Srv.CompaniesService.GetCompanies(ctx, models.Company{
                Name:    data.Name,
                Code:    data.Code,
                Country: data.Country,
                Website: data.Website,
                Phone:   data.Phone,
        })
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to get companies", zap.Error(err))
                return base.Response{
                        "err": err.Error(),
                }, errors.New(`global error`)
        }</span>
        <span class="cov4" title="2">return base.Response{
                "companies": cmp,
        }, nil</span>
}

func (a *CompaniesAPI) UpdateCompany(ctx context.Context, rw http.ResponseWriter, r *http.Request) (any, error) <span class="cov7" title="4">{
        log := logger.FromContext(ctx).With(zap.String("method", "UpdateCompany"))
        compID, err := base.GetVarInt(r, `id`)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to parse company id from request url", zap.Error(err))
                return base.Response{}, errors.New(`company id required`)
        }</span>

        <span class="cov6" title="3">var data models.Company
        err = base.DecodeBody(&amp;data, r)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to parse request body", zap.Error(err))
                return base.Response{}, errors.New(`incorrect params`)
        }</span>

        <span class="cov4" title="2">newComp, err := a.Srv.CompaniesService.UpdateCompany(ctx, uint64(compID), data)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to update company", zap.Error(err))
                return base.Response{
                        "err": err.Error(),
                }, err
        }</span>
        <span class="cov1" title="1">return base.Response{
                "company": newComp,
        }, nil</span>
}

func (a *CompaniesAPI) DeleteCompany(ctx context.Context, rw http.ResponseWriter, r *http.Request) (any, error) <span class="cov10" title="6">{
        log := logger.FromContext(ctx).With(zap.String("method", "DeleteCompany"))
        _, err := a.VerifyUser(r)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to verify user")
                return nil, err
        }</span>
        <span class="cov9" title="5">stat, err := a.Srv.AuthService.IsActionAllowed(auth.ActionCompanyDelete, r.RemoteAddr)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to verify user location", zap.Error(err))
        }</span>
        <span class="cov9" title="5">if !a.Srv.Config.DevMode &amp;&amp; !stat </span><span class="cov4" title="2">{
                log.Info("Action is not allowed due to region restrictions", zap.String("remote_addr", r.RemoteAddr))
                return nil, errors.New(`not authorized`)
        }</span>

        <span class="cov6" title="3">compID, err := base.GetVarInt(r, `id`)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to parse company id from request", zap.Error(err))
                return base.Response{}, errors.New(`company id required`)
        }</span>

        <span class="cov4" title="2">err = a.Srv.CompaniesService.DeleteCompany(ctx, uint64(compID))
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to delete company", zap.Error(err))
                return base.Response{
                        "err": err.Error(),
                }, err
        }</span>
        <span class="cov1" title="1">return base.Response{}, nil</span>
}

func (a *CompaniesAPI) CreateCompany(ctx context.Context, rw http.ResponseWriter, r *http.Request) (any, error) <span class="cov10" title="6">{
        log := logger.FromContext(ctx).With(zap.String("method", "CreateCompany"))
        _, err := a.VerifyUser(r)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to verify user", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov9" title="5">stat, err := a.Srv.AuthService.IsActionAllowed(auth.ActionCompanyCreate, r.RemoteAddr)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to verify user location", zap.String("remote_addr", r.RemoteAddr), zap.Error(err))
        }</span>
        <span class="cov9" title="5">if !a.Srv.Config.DevMode &amp;&amp; !stat </span><span class="cov4" title="2">{
                log.Info("Action is not allowed due to region restrictions", zap.String("remote_addr", r.RemoteAddr))
                return nil, errors.New(`not authorized`)
        }</span>
        <span class="cov6" title="3">var userData models.Company
        err = base.DecodeBody(&amp;userData, r)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to decode request body", zap.Error(err))
                return base.Response{}, errors.New(`incorrect params`)
        }</span>

        <span class="cov4" title="2">compID, err := a.Srv.CompaniesService.CreateCompany(ctx, userData)
        if err != nil </span><span class="cov1" title="1">{
                log.Error("Failed to create company", zap.Error(err))
                return base.Response{
                        "err": err.Error(),
                }, errors.New("server error")
        }</span>

        <span class="cov1" title="1">return base.Response{
                "company_id": compID,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

type Action int

const (
        ActionCompanyCreate = iota + 1
        ActionCompanyDelete
)

func (s *service) IsActionAllowed(action Action, ip string) (bool, error) <span class="cov8" title="6">{
        switch action </span>{
        case ActionCompanyCreate, ActionCompanyDelete:<span class="cov7" title="5">
                country, err := s.client.GetRequestLocation(ip)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov6" title="4">return isCountryAllowed(action, country), nil</span>
        default:<span class="cov1" title="1">
                return false, nil</span>
        }
}

func isCountryAllowed(action Action, country string) bool <span class="cov10" title="9">{
        switch action </span>{
        case ActionCompanyCreate, ActionCompanyDelete:<span class="cov9" title="8">
                return country == "CY"</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

type AuthService interface {
        IsActionAllowed(action Action, ip string) (bool, error)
}

type IPDataProvider interface {
        GetRequestLocation(ip string) (string, error)
}

type service struct {
        client IPDataProvider
}

func NewService(ipDataProvider IPDataProvider) *service <span class="cov0" title="0">{
        return &amp;service{
                client: ipDataProvider,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/golang-jwt/jwt"
)

// JWTClaims is a struct of JWT payload
type JWTClaims struct {
        ID string `json:"user_id"`
        jwt.StandardClaims
}

type JWTUser struct {
        JWT string `json:"jwt"`
        ID  int64  `json:"id"`
}

// Parse JWT into JWTUser
func (ju *JWTUser) Parse(jwtToken, jwtSecret string) (*JWTUser, error) <span class="cov10" title="4">{
        if len(jwtToken) &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("auth parsing error: JWT is empty")
        }</span>

        <span class="cov8" title="3">token, err := jwt.ParseWithClaims(jwtToken, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="2">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov5" title="2">return []byte(jwtSecret), nil</span>
        })
        <span class="cov8" title="3">if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf(`auth error: %w`, err)
        }</span>

        <span class="cov5" title="2">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov5" title="2">{
                id, err := strconv.ParseInt(claims.ID, 10, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf(`auth error: %w`, err)
                }</span>

                <span class="cov1" title="1">ju = &amp;JWTUser{JWT: jwtToken, ID: id}
                return ju, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf(`auth error: %w`, err)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by mockery v2.10.6. DO NOT EDIT.

package auth

import mock "github.com/stretchr/testify/mock"

// MockAuthService is an autogenerated mock type for the AuthService type
type MockAuthService struct {
        mock.Mock
}

// IsActionAllowed provides a mock function with given fields: action, ip
func (_m *MockAuthService) IsActionAllowed(action Action, ip string) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(action, ip)

        var r0 bool
        if rf, ok := ret.Get(0).(func(Action, string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(action, ip)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(Action, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(action, ip)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by mockery v2.10.6. DO NOT EDIT.

package auth

import mock "github.com/stretchr/testify/mock"

// MockIPDataProvider is an autogenerated mock type for the IPDataProvider type
type MockIPDataProvider struct {
        mock.Mock
}

// GetRequestLocation provides a mock function with given fields: ip
func (_m *MockIPDataProvider) GetRequestLocation(ip string) (string, error) <span class="cov10" title="5">{
        ret := _m.Called(ip)

        var r0 string
        if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ip)
        }</span> else<span class="cov10" title="5"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov10" title="5">var r1 error
        if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ip)
        }</span> else<span class="cov10" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="5">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package companies

import (
        "context"

        "github.com/M-Fisher/companies_api/app/internal/models"
        "github.com/M-Fisher/companies_api/app/internal/services/auth"
        "github.com/M-Fisher/companies_api/app/internal/services/events"
        "github.com/M-Fisher/companies_api/app/internal/storage/postgres"
        "go.uber.org/zap"
)

type CompaniesService interface {
        CreateCompany(ctx context.Context, company models.Company) (uint64, error)
        DeleteCompany(ctx context.Context, companyID uint64) error
        GetCompanies(ctx context.Context, params models.Company) ([]*models.Company, error)
        UpdateCompany(ctx context.Context, compID uint64, company models.Company) (*models.Company, error)
}

type service struct {
        db          *postgres.DB
        authService auth.AuthService
        event       events.EventsService
        log         *zap.Logger
}

func NewService(db *postgres.DB, authService auth.AuthService, eventService events.EventsService, log *zap.Logger) *service <span class="cov0" title="0">{
        return &amp;service{
                db:          db,
                authService: authService,
                event:       eventService,
                log:         log,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package companies

import (
        "context"
        "encoding/json"
        "errors"

        "github.com/M-Fisher/companies_api/app/internal/models"
        "github.com/M-Fisher/companies_api/app/internal/services/events"
        "github.com/M-Fisher/companies_api/app/internal/storage/postgres"
        "go.uber.org/zap"
)

func (s *service) CreateCompany(ctx context.Context, company models.Company) (uint64, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.log.Debug("Skipping creating company due to ctx cancelled")
                return 0, ctx.Err()</span>
        default:<span class="cov0" title="0">
                var (
                        compID *uint64
                        err    error
                )
                err = s.db.ExecTx(ctx, func(q *postgres.Queries) error </span><span class="cov0" title="0">{
                        compID, err = q.CreateCompany(ctx, makeDBCompanyFromRequest(&amp;company))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if compID == nil </span><span class="cov0" title="0">{
                                return errors.New(`failed to create company`)
                        }</span>

                        <span class="cov0" title="0">dbCompany, err := q.GetCompanyByID(ctx, *compID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">resJSON, err := json.Marshal(makeCompanyFromDBResponse(dbCompany))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = s.event.SendEvent(ctx, events.EventCompanyCreated, resJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Error("Failed to send event", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">return err</span>
                })
                <span class="cov0" title="0">if compID != nil </span><span class="cov0" title="0">{
                        return *compID, err
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package companies

import (
        "context"
        "fmt"

        "github.com/M-Fisher/companies_api/app/internal/services/events"
        "go.uber.org/zap"
)

func (s *service) DeleteCompany(ctx context.Context, companyID uint64) error <span class="cov10" title="4">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                s.log.Debug("Skipping deleting company due to ctx cancelled")
                return ctx.Err()</span>
        default:<span class="cov8" title="3">
                err := s.db.Queries.DeleteCompany(ctx, companyID)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov5" title="2">err = s.event.SendEvent(ctx, events.EventCompanyDeleted, []byte(fmt.Sprintf(`{"id": %d}`, companyID)))
                if err != nil </span><span class="cov1" title="1">{
                        s.log.Error("Failed to send event", zap.Error(err))
                }</span>

                <span class="cov5" title="2">return err</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package companies

import (
        "context"

        "github.com/M-Fisher/companies_api/app/internal/models"
)

func (s *service) GetCompanies(ctx context.Context, params models.Company) ([]*models.Company, error) <span class="cov10" title="3">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                s.log.Debug("Skipping getting companies due to ctx cancelled")
                return nil, ctx.Err()</span>
        default:<span class="cov6" title="2">
                companies, err := s.db.Queries.GetCompanies(ctx, makeDBCompanyFromRequest(&amp;params))
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">res := make([]*models.Company, len(companies))
                for i, c := range companies </span><span class="cov6" title="2">{
                        res[i] = makeCompanyFromDBResponse(c)
                }</span>
                <span class="cov1" title="1">return res, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package companies

import (
        "github.com/M-Fisher/companies_api/app/internal/models"
        "github.com/M-Fisher/companies_api/app/internal/storage/postgres"
)

func makeCompanyFromDBResponse(comp *postgres.Company) *models.Company <span class="cov10" title="2">{
        return &amp;models.Company{
                ID:      uint64(comp.ID),
                Name:    comp.Name,
                Code:    comp.Code,
                Country: comp.Country,
                Website: comp.Website,
                Phone:   comp.Phone,
        }
}</span>

func makeDBCompanyFromRequest(comp *models.Company) postgres.Company <span class="cov10" title="2">{
        return postgres.Company{
                Name:    comp.Name,
                Code:    comp.Code,
                Country: comp.Country,
                Website: comp.Website,
                Phone:   comp.Phone,
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by mockery v2.10.6. DO NOT EDIT.

package companies

import (
        context "context"

        models "github.com/M-Fisher/companies_api/app/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockCompaniesService is an autogenerated mock type for the CompaniesService type
type MockCompaniesService struct {
        mock.Mock
}

// CreateCompany provides a mock function with given fields: ctx, company
func (_m *MockCompaniesService) CreateCompany(ctx context.Context, company models.Company) (uint64, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, company)

        var r0 uint64
        if rf, ok := ret.Get(0).(func(context.Context, models.Company) uint64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, company)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(uint64)
        }</span>

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, models.Company) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, company)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// DeleteCompany provides a mock function with given fields: ctx, companyID
func (_m *MockCompaniesService) DeleteCompany(ctx context.Context, companyID uint64) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, companyID)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, uint64) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, companyID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// GetCompanies provides a mock function with given fields: ctx, params
func (_m *MockCompaniesService) GetCompanies(ctx context.Context, params models.Company) ([]*models.Company, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, params)

        var r0 []*models.Company
        if rf, ok := ret.Get(0).(func(context.Context, models.Company) []*models.Company); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Company)
                }</span>
        }

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, models.Company) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UpdateCompany provides a mock function with given fields: ctx, compID, company
func (_m *MockCompaniesService) UpdateCompany(ctx context.Context, compID uint64, company models.Company) (*models.Company, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, compID, company)

        var r0 *models.Company
        if rf, ok := ret.Get(0).(func(context.Context, uint64, models.Company) *models.Company); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, compID, company)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Company)
                }</span>
        }

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, uint64, models.Company) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, compID, company)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package companies

import (
        "context"
        "encoding/json"
        "errors"

        "github.com/M-Fisher/companies_api/app/internal/models"
        "github.com/M-Fisher/companies_api/app/internal/services/events"
        "github.com/M-Fisher/companies_api/app/internal/storage/postgres"
        "go.uber.org/zap"
)

func (s *service) UpdateCompany(ctx context.Context, compID uint64, company models.Company) (*models.Company, error) <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.log.Debug("Skipping getting companies due to ctx cancelled")
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                var res *models.Company
                err := s.db.ExecTx(ctx, func(q *postgres.Queries) error </span><span class="cov0" title="0">{
                        compID, err := q.UpdateCompany(ctx, compID, makeDBCompanyFromRequest(&amp;company))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if compID == nil </span><span class="cov0" title="0">{
                                return errors.New(`company not found`)
                        }</span>
                        <span class="cov0" title="0">dbCompany, err := q.GetCompanyByID(ctx, *compID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">res = makeCompanyFromDBResponse(dbCompany)
                        resJSON, err := json.Marshal(res)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">err = s.event.SendEvent(ctx, events.EventCompanyUpdated, resJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                s.log.Error("Failed to send event", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">return err</span>
                })

                <span class="cov0" title="0">return res, err</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
